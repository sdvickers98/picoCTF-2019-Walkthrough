# OverFlow 0
100 points

### Description
*"This should be easy. Overflow the correct buffer in this program and get a flag. Its also found in /problems/overflow-0_0_6d0c88d7d40bc281760b515cb6a4660a on the shell server. Source."*

### Solution
The source code provided for the program we want to exploit looks like this:
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[128];
  strcpy(buf, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  if (argc > 1) {
    vuln(argv[1]);
    printf("You entered: %s", argv[1]);
  }
  else
    printf("Please enter an argument next time\n");
  return 0;
}
```

Let's look at what this program does. I'm just going to go over the main functionality that is related to solving the problem.

This program starts by opening the flag file (which we don't have read permissions for) and copying its contents to the `flag` buffer. Then, it checks for command-line arguments, and, if there are any provided, it runs `vuln()` on the first of these arguments. If there are no command-line arguments, the program tells the user to run it with an argument next time, and exits.

`vuln` takes a string as input and copies it to a 128-character buffer **without** checking that the string's length is less than or equal to 128 characters. `strcpy` does not check either. **This** is the vulnerability we must exploit.

Because there is no check that the input is less than 128 characters, but `buf` can only hold 128 characters, this program is vulnerable to a **buffer overflow**.

So, what would happen if we tried to use an input that is 129 characters long? We can generate this easily with python.
```
$ python -c "print('a'*129)"
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```
**NOTE**: The expression `'a'*129` is just an easy way to make a string of 129 a's in python. You can do this using any character. It can also be with python lists. For example, `[0]*100` makes a list of 100 zeroes.

Just copy the python output to use as the command-line argument for `vuln`. So what happens when we try this?
```
$ ./vuln aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
You entered: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

Well that's weird, it didn't break the program. What if we try 130 characters? Or 131? I'll save you the trouble by going ahead and telling you the magic number that actually changes the program's behavior is 133. If we run the same command with 133 characters, we just get the flag as output.

So why 133? Well, C sometimes allocates memory space for arrays and structs based on an **alignment**, usually 8 or 16 bytes. In this case, it is 8 bytes. This just means that once C has allocated the space that we ask for (128 bytes), it pads that memory with extra bytes until the entire memory block is a size that is divisible by 8. 

128 is not evenly divisible by 8, but 132 is. So, C padded the memory allocated for `buf` with 4 extra bytes, so we didn't fully overload the buffer until we used 133 characters. There are various different reasons for why alignments exist, and the use of alignment (and the alignment size that is used) is often determined by the architecture of the OS.

I'll go into the details about how buffer overlows actually work and what's going on behind the scenes in later walkthroughs. For now, you should just know that we exploited a vulnerability in the program where it is allocating space for a buffer of 128 characters, but it never actually checks to make sure that our input is small enough to fit in the buffer. This allows us to create unintended behavior in the program.

<details>
  <summary>Flag:</summary>
  picoCTF{3asY_P3a5y0a131490}
</details>

[Next Problem](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%234%20-%20Overflow%201.md)

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
