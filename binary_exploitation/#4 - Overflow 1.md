# Overflow 1
150 points

### Description
*"You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in /problems/overflow-1_1_e792baa0d29d24699530e6a26071a260 on the shell server. Source."*

### Solution 
From here on out I'm going to start attempting each binary exploitation problem *without* peeking at the source code first. This is because in a real-world situation, such as in pentesting, you wouldn't normally have access to the source code of the program that you're trying to exploit.

So, what do we do instead? Well, we take the hints that the problem gives us into consideration, whether its the name or something in the description of the problem. You can also click the hints button in picoCTF to get another hint or two, and these are often links to pages about the type of exploit that should be used in the problem.

Other than hints, we just have to go by trial and error. So, we know from the name and the description that the problem involves a buffer overflow. Let's try a few inputs of different sizes.
```
$ ./vuln
Give me a string and lets see what happens: 
a
Woah, were jumping to 0x8048705 !
$ ./vuln
Give me a string and lets see what happens: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Woah, were jumping to 0x8048705 !
$ ./vuln
Give me a string and lets see what happens: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Woah, were jumping to 0x61616161 !
Segmentation fault (core dumped)
```

So it seems that we overflowed the buffer on the third try since the printed-out value changed and the program crashed. If you know your ASCII hex values, you may have also noticed that the value printed out, `0x61616161` is a 32-bit memory block of 4 a's, since `0x61` is the ASCII hex value for lowercase 'A'.

What's happening here? Well, first we need to talk about one of the most fundamental concepts in program execution and memory structure: the **stack**.

#### The Stack
If you aren't familiar with the stack data structure, you can picture it as a literal stack of items, say books. You add, or **push**, books to the stack by placing them on the top and remove, or **pop**, books from the top as well. If you want to get the third book from the top, well you have to remove the top two first, one at a time.

You probably wouldn't act this way with a real stack of books, but it's still a good example. The stack is what's called a **first in, last out** data structure, meaning the first items that go into it are the last ones that come out. In other words, when we pop an item from the stack, we will get the last item that was pushed to the stack. 

In the context of memory usage, the stack is actually implemented "upside-down".

<details>
  <summary>Flag:</summary>
  flag
</details>

[Next Problem]()

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
