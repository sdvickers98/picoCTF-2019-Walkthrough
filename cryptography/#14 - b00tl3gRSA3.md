# b00tl3gRSA3
450 points

### Description
*"Why use p and q when I can use more? Connect with nc 2019shell1.picoctf.com 32246."*

### Solution.
The netcat command gives us this output:
```
c: 19917275585980796449198654702643881463866259081099180147660677550017266804143647536239273206662674516541170246433647342125030297304125335283770925537720663128307037358615671099881833745794284389593987728640359305511677530773509594499624086860149695080575581825814156925179497214532322738250051834463862808383851177854144316327924418884700269606
n: 24743076544307378029439438934691983636592821280506800321671071877770817095888762269304705230716959073487835338303901201537927199370318875296963092116868221883457102127173920239837201194883126169845096350858585618633295385160689433201606899279431183933235128978735654790909430515270889975466281471118588710004292183104780428112492179434246094683
e: 65537
```
**NOTE:** This is one of those problems where *n*, *c*, and the flag will be different for each user. Make sure to you **your** variables.

The prompt is telling us that there are likely other prime factors of *n* besides *p* and *q*. We can figure out all of the factors of *n* just by using an [integer
factorization calculator](https://www.alpertron.com.ar/ECM.HTM). This calculator also gives us the value of Euler's totient function for this *n*, so we can figure 
*d* out easily. This is why you shouldn't have an *n* with more than 2 prime factors. To get rid of the spaces in that totient function number:
```python
phi = '24 743076 475920 573556 767627 459861 656784 994393 825275 037810 971639 170497 516242 852396 349929 947918 091915 798580 197890 196277 106289 624603 574953 093245 061953 655578 763336 554530 832088 346251 798820 986205 843274 971054 847337 138851 279436 145185 866285 213197 685796 919607 081638 654262 847567 092829 300121 018265 979186 106012 297203 436592 562609 903675 283341 312000 000000 000000'
phi = int(''.join(phi.split()))
```
From here, we can get *d* and decrypt easily:
```python
from Crypto.Util.number import inverse, long_to_bytes

e = 65537
n = 24743076544307378029439438934691983636592821280506800321671071877770817095888762269304705230716959073487835338303901201537927199370318875296963092116868221883457102127173920239837201194883126169845096350858585618633295385160689433201606899279431183933235128978735654790909430515270889975466281471118588710004292183104780428112492179434246094683
c = 19917275585980796449198654702643881463866259081099180147660677550017266804143647536239273206662674516541170246433647342125030297304125335283770925537720663128307037358615671099881833745794284389593987728640359305511677530773509594499624086860149695080575581825814156925179497214532322738250051834463862808383851177854144316327924418884700269606
d = inverse(e, phi)

flag = long_to_bytes(pow(c,d,n)).decode()
print(flag)
```

Remember, you're flag will be unique to you, but it should follow the format below with the X's replaced with random characters.
<details>
  <summary>Flag:</summary>
  picoCTF{too_many_fact0rs_XXXXXXX}
</details>

[Next Problem](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/cryptography/%2315%20-%20john_pollard.md)

[Return to Cryptography](https://github.com/sdvickers98/picoCTF-2019-Walkthrough/blob/master/cryptography/%230%20-%20Cryptography%20Home%20Page.md)

[Return to Homepage](https://github.com/sdvickers98/picoCTF-2019-Walkthrough)

